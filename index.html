<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Harmonic Analyzer">
    <title>Harmonic Analyzer Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #12182b;
            --bg-tertiary: #1a2235;
            --accent-primary: #00f0ff;
            --accent-secondary: #ff00ea;
            --accent-tertiary: #00ff88;
            --text-primary: #ffffff;
            --text-secondary: #8b95b8;
            --text-muted: #4a5578;
            --surface: rgba(26, 34, 53, 0.6);
            --surface-elevated: rgba(26, 34, 53, 0.9);
            --glow-cyan: rgba(0, 240, 255, 0.3);
            --glow-magenta: rgba(255, 0, 234, 0.3);
        }

```
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }

    body {
        font-family: 'JetBrains Mono', monospace;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
        overflow-x: hidden;
        position: relative;
    }

    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
            radial-gradient(circle at 20% 30%, var(--glow-cyan) 0%, transparent 50%),
            radial-gradient(circle at 80% 70%, var(--glow-magenta) 0%, transparent 50%);
        pointer-events: none;
        z-index: 0;
        opacity: 0.15;
    }

    .grain {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.03;
        pointer-events: none;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        z-index: 1;
    }

    .container {
        position: relative;
        z-index: 2;
        max-width: 1400px;
        margin: 0 auto;
        padding: 40px 20px;
    }

    .header {
        text-align: center;
        margin-bottom: 60px;
        animation: slideDown 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-30px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .logo {
        font-family: 'Orbitron', sans-serif;
        font-size: 48px;
        font-weight: 900;
        letter-spacing: -2px;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 8px;
        text-transform: uppercase;
        position: relative;
        display: inline-block;
    }

    .logo::after {
        content: '';
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 60%;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
    }

    .tagline {
        font-size: 13px;
        letter-spacing: 3px;
        color: var(--text-secondary);
        text-transform: uppercase;
        font-weight: 300;
    }

    .badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: var(--surface-elevated);
        border: 1px solid rgba(0, 240, 255, 0.3);
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 11px;
        margin-top: 16px;
        color: var(--accent-primary);
        font-weight: 500;
        backdrop-filter: blur(10px);
    }

    .badge::before {
        content: '‚óè';
        animation: pulse-dot 2s ease-in-out infinite;
    }

    @keyframes pulse-dot {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.5; transform: scale(0.8); }
    }

    .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
    }

    @media (max-width: 968px) {
        .grid {
            grid-template-columns: 1fr;
        }
    }

    .card {
        background: var(--surface);
        backdrop-filter: blur(20px);
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        padding: 32px;
        position: relative;
        overflow: hidden;
        animation: fadeInUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) backwards;
    }

    .card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
        opacity: 0.5;
    }

    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .card:nth-child(1) { animation-delay: 0.1s; }
    .card:nth-child(2) { animation-delay: 0.2s; }
    .card:nth-child(3) { animation-delay: 0.3s; }

    .card-title {
        font-family: 'Orbitron', sans-serif;
        font-size: 18px;
        font-weight: 700;
        margin-bottom: 24px;
        color: var(--text-primary);
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .control-panel {
        text-align: center;
    }

    .btn {
        font-family: 'JetBrains Mono', monospace;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
        border: none;
        padding: 20px 48px;
        font-size: 15px;
        font-weight: 700;
        border-radius: 50px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 12px;
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 10px 40px rgba(0, 240, 255, 0.3);
        position: relative;
        overflow: hidden;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
        opacity: 0;
        transition: opacity 0.3s;
    }

    .btn:hover::before {
        opacity: 1;
    }

    .btn span {
        position: relative;
        z-index: 1;
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 50px rgba(0, 240, 255, 0.5);
    }

    .btn:active {
        transform: translateY(0);
    }

    .btn.stop {
        background: linear-gradient(135deg, #ff0055, #ff4488);
        box-shadow: 0 10px 40px rgba(255, 0, 85, 0.3);
    }

    .btn.stop::before {
        background: linear-gradient(135deg, #ff4488, #ff0055);
    }

    .btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }

    .recording-status {
        margin-top: 24px;
        padding: 20px;
        background: rgba(0, 240, 255, 0.05);
        border: 1px solid rgba(0, 240, 255, 0.2);
        border-radius: 16px;
        display: none;
    }

    .recording-status.active {
        display: block;
        animation: fadeInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .rec-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-bottom: 12px;
    }

    .rec-dot {
        width: 12px;
        height: 12px;
        background: #ff0055;
        border-radius: 50%;
        box-shadow: 0 0 20px rgba(255, 0, 85, 0.8);
        animation: pulse-rec 1.5s ease-in-out infinite;
    }

    @keyframes pulse-rec {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.3); opacity: 0.7; }
    }

    .rec-time {
        font-family: 'Orbitron', sans-serif;
        font-size: 24px;
        font-weight: 700;
        color: var(--accent-primary);
    }

    .rec-hint {
        font-size: 11px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .analyzing {
        text-align: center;
        padding: 40px;
        display: none;
    }

    .analyzing.active {
        display: block;
    }

    .spinner {
        width: 60px;
        height: 60px;
        margin: 0 auto 24px;
        border: 3px solid rgba(0, 240, 255, 0.1);
        border-top: 3px solid var(--accent-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .analyzing-text {
        font-family: 'Orbitron', sans-serif;
        font-size: 16px;
        color: var(--accent-primary);
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .analyzing-step {
        font-size: 12px;
        color: var(--text-secondary);
    }

    .results {
        display: none;
    }

    .results.active {
        display: block;
    }

    .metrics {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 32px;
    }

    .metric {
        background: var(--bg-secondary);
        border: 1px solid rgba(0, 240, 255, 0.1);
        border-radius: 20px;
        padding: 28px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .metric:hover {
        border-color: rgba(0, 240, 255, 0.3);
        transform: translateY(-2px);
    }

    .metric::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, var(--glow-cyan) 0%, transparent 70%);
        opacity: 0.1;
        pointer-events: none;
    }

    .metric-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-muted);
        margin-bottom: 12px;
        font-weight: 500;
    }

    .metric-value {
        font-family: 'Orbitron', sans-serif;
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        line-height: 1;
        margin-bottom: 8px;
    }

    .metric-sub {
        font-size: 11px;
        color: var(--text-secondary);
        min-height: 16px;
    }

    .confidence-bar {
        margin-top: 16px;
        height: 4px;
        background: rgba(0, 240, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
        position: relative;
    }

    .confidence-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent-primary), var(--accent-tertiary));
        border-radius: 2px;
        transition: width 1s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 0 10px var(--accent-primary);
    }

    .confidence-text {
        font-size: 10px;
        color: var(--text-muted);
        margin-top: 8px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .camelot-section {
        margin: 32px 0;
    }

    .camelot-title {
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-secondary);
        margin-bottom: 24px;
    }

    .wheel-container {
        position: relative;
        width: 320px;
        height: 320px;
        margin: 0 auto;
    }

    .wheel-svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 10px 40px rgba(0, 240, 255, 0.2));
    }

    .current-position {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
        width: 100px;
        height: 100px;
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        box-shadow: 0 10px 40px rgba(0, 240, 255, 0.5);
        border: 3px solid var(--bg-primary);
    }

    .position-code {
        font-family: 'Orbitron', sans-serif;
        font-size: 32px;
        font-weight: 900;
    }

    .position-key {
        font-size: 12px;
        opacity: 0.8;
        margin-top: 4px;
    }

    .compatible-section {
        margin: 32px 0;
        padding: 24px;
        background: var(--bg-secondary);
        border: 1px solid rgba(0, 240, 255, 0.1);
        border-radius: 20px;
    }

    .section-title {
        font-family: 'Orbitron', sans-serif;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-secondary);
        margin-bottom: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .key-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
    }

    .key-tag {
        background: rgba(0, 240, 255, 0.1);
        border: 1px solid rgba(0, 240, 255, 0.3);
        padding: 12px 20px;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 500;
        color: var(--accent-primary);
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        cursor: default;
    }

    .key-tag:hover {
        background: rgba(0, 240, 255, 0.2);
        transform: translateY(-2px);
    }

    .key-tag.perfect {
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
        border-color: transparent;
        font-weight: 700;
    }

    .details-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
    }

    .detail-row {
        display: flex;
        justify-content: space-between;
        padding: 12px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        font-size: 12px;
    }

    .detail-label {
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 10px;
    }

    .detail-value {
        color: var(--accent-primary);
        font-weight: 500;
    }

    .audio-player {
        width: 100%;
        margin-top: 24px;
        border-radius: 12px;
        filter: saturate(0) brightness(0.8) contrast(1.2);
    }

    .debug-panel {
        margin-top: 24px;
        padding: 16px;
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(0, 240, 255, 0.1);
        border-radius: 12px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 10px;
        color: var(--text-secondary);
        max-height: 200px;
        overflow-y: auto;
        line-height: 1.6;
        display: none;
    }

    .debug-panel.active {
        display: block;
    }

    .error {
        background: rgba(255, 0, 85, 0.1);
        border: 1px solid rgba(255, 0, 85, 0.3);
        color: #ff4488;
        padding: 16px;
        border-radius: 12px;
        margin-top: 16px;
        font-size: 13px;
        display: none;
    }

    .error.active {
        display: block;
        animation: fadeInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @media (max-width: 768px) {
        .logo {
            font-size: 36px;
        }

        .metrics {
            grid-template-columns: 1fr;
        }

        .details-grid {
            grid-template-columns: 1fr;
        }

        .wheel-container {
            width: 280px;
            height: 280px;
        }
    }

    ::-webkit-scrollbar {
        width: 8px;
    }

    ::-webkit-scrollbar-track {
        background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
        background: var(--accent-primary);
        border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: var(--accent-secondary);
    }
</style>
```

</head>
<body>
    <div class="grain"></div>

```
<div class="container">
    <header class="header">
        <h1 class="logo">Harmonic</h1>
        <p class="tagline">Professional Audio Analysis</p>
        <span class="badge">Studio-Grade Detection Algorithms</span>
    </header>

    <div class="grid">
        <div class="card control-panel">
            <h2 class="card-title">Live Capture</h2>
            <p style="color: var(--text-secondary); margin-bottom: 24px; font-size: 13px;">
                Play a track and analyze through your microphone
            </p>

            <div id="recordingControls">
                <button class="btn" id="startBtn">
                    <span>üé§</span>
                    <span>Start Listening</span>
                </button>
                <button class="btn stop" id="stopBtn" style="display: none;">
                    <span>‚èπ</span>
                    <span>Stop & Analyze</span>
                </button>
            </div>

            <div class="recording-status" id="recordingStatus">
                <div class="rec-indicator">
                    <div class="rec-dot"></div>
                    <div class="rec-time" id="recordingTime">0:00</div>
                </div>
                <p class="rec-hint">Recording ‚Äî 30s minimum for best accuracy</p>
            </div>

            <div class="analyzing" id="analyzing">
                <div class="spinner"></div>
                <p class="analyzing-text">Analyzing</p>
                <p class="analyzing-step" id="analyzingStep">Processing audio...</p>
            </div>

            <div class="error" id="error"></div>
        </div>

        <div class="card results" id="resultsCard">
            <h2 class="card-title">Detection Results</h2>
            
            <div class="metrics">
                <div class="metric">
                    <div class="metric-label">BPM</div>
                    <div class="metric-value" id="bpmValue">--</div>
                    <div class="metric-sub" id="bpmCandidates"></div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="bpmConfidence" style="width: 0%"></div>
                    </div>
                    <div class="confidence-text" id="bpmConfidenceText"></div>
                </div>
                
                <div class="metric">
                    <div class="metric-label">Musical Key</div>
                    <div class="metric-value" id="keyValue" style="font-size: 32px;">--</div>
                    <div class="metric-sub" id="keyCandidates"></div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="keyConfidence" style="width: 0%"></div>
                    </div>
                    <div class="confidence-text" id="keyConfidenceText"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="card results" id="results" style="animation-delay: 0.4s;">
        <div class="camelot-section">
            <h3 class="camelot-title">Camelot Wheel Position</h3>
            <div class="wheel-container">
                <svg class="wheel-svg" viewBox="0 0 300 300">
                    <g id="outerRing"></g>
                    <g id="innerRing"></g>
                </svg>
                <div class="current-position" id="currentPosition">
                    <div class="position-code" id="positionCode">--</div>
                    <div class="position-key" id="positionKey">--</div>
                </div>
            </div>
        </div>

        <div class="compatible-section">
            <h3 class="section-title">
                <span>‚ú®</span>
                <span>Compatible Mixing Keys</span>
            </h3>
            <div class="key-tags" id="compatibleKeys"></div>
        </div>

        <div class="compatible-section">
            <h3 class="section-title">
                <span>üìä</span>
                <span>Analysis Details</span>
            </h3>
            <div class="details-grid">
                <div class="detail-row">
                    <span class="detail-label">Key Method</span>
                    <span class="detail-value" id="keyMethod">--</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">BPM Method</span>
                    <span class="detail-value" id="bpmMethod">--</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Camelot</span>
                    <span class="detail-value" id="camelotDetail">--</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Duration</span>
                    <span class="detail-value" id="durationAnalyzed">--</span>
                </div>
            </div>
        </div>

        <audio id="audioPlayer" class="audio-player" controls></audio>

        <div class="debug-panel" id="debugInfo"></div>
    </div>
</div>

<script>
    // PROFESSIONAL CAMELOT WHEEL MAPPING
    const CAMELOT_WHEEL = {
        'C major': '8B', 'Db major': '3B', 'D major': '10B', 'Eb major': '5B',
        'E major': '12B', 'F major': '7B', 'F# major': '2B', 'Gb major': '2B',
        'G major': '9B', 'Ab major': '4B', 'A major': '11B', 'Bb major': '6B', 'B major': '1B',
        'C minor': '5A', 'C# minor': '12A', 'D minor': '7A', 'D# minor': '2A', 'Eb minor': '2A',
        'E minor': '9A', 'F minor': '4A', 'F# minor': '11A', 'G minor': '6A',
        'G# minor': '1A', 'Ab minor': '1A', 'A minor': '8A', 'A# minor': '3A', 'Bb minor': '3A', 'B minor': '10A'
    };

    const CAMELOT_TO_KEY = Object.fromEntries(
        Object.entries(CAMELOT_WHEEL).map(([key, camelot]) => [camelot, key])
    );

    // Krumhansl-Schmuckler key profiles
    const KEY_PROFILES = {
        major: [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88],
        minor: [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17]
    };

    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const NOTE_NAMES_FLAT = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

    let audioContext;
    let mediaRecorder;
    let audioChunks = [];
    let recordingStartTime;
    let recordingInterval;
    let stream;
    let debugLog = [];

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordingStatus = document.getElementById('recordingStatus');
    const recordingTime = document.getElementById('recordingTime');

    startBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);

    function log(msg) {
        debugLog.push(msg);
        console.log(msg);
    }

    async function startRecording() {
        try {
            debugLog = [];
            hideError();
            hideResults();
            
            stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                    sampleRate: 44100
                } 
            });

            audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
            
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus',
                audioBitsPerSecond: 128000
            });
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await processAudio(audioBlob);
            };

            mediaRecorder.start();
            
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-flex';
            recordingStatus.classList.add('active');
            
            recordingStartTime = Date.now();
            recordingInterval = setInterval(updateRecordingTime, 100);

        } catch (error) {
            showError('Microphone access denied. Please allow microphone access and try again.');
            console.error('Error accessing microphone:', error);
        }
    }

    function updateRecordingTime() {
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        recordingTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            clearInterval(recordingInterval);
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            stopBtn.style.display = 'none';
            startBtn.style.display = 'inline-flex';
            recordingStatus.classList.remove('active');
            showAnalyzing();
        }
    }

    async function processAudio(blob) {
        try {
            updateAnalyzingStep('Decoding audio...');
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            log(`Audio decoded: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.sampleRate}Hz`);

            updateAnalyzingStep('Running BPM detection algorithms...');
            const bpmResult = await detectBPMPrecision(audioBuffer);
            
            updateAnalyzingStep('Analyzing harmonic content for key...');
            const keyResult = await detectKeyPrecision(audioBuffer);
            
            displayResults(bpmResult, keyResult, audioBuffer.duration);
            
            const audioPlayer = document.getElementById('audioPlayer');
            audioPlayer.src = URL.createObjectURL(blob);
            
        } catch (error) {
            showError('Error analyzing audio: ' + error.message);
            console.error('Processing error:', error);
        } finally {
            hideAnalyzing();
        }
    }

    function updateAnalyzingStep(text) {
        document.getElementById('analyzingStep').textContent = text;
    }

    // ===== PRECISION BPM DETECTION =====
    // Using beat histogram analysis + tempo induction
    async function detectBPMPrecision(buffer) {
        const sampleRate = buffer.sampleRate;
        const channelData = buffer.getChannelData(0);
        
        log('Starting precision BPM detection...');
        
        // Step 1: Extract onset envelope
        const onsetEnvelope = extractOnsetEnvelope(channelData, sampleRate);
        log(`Onset envelope extracted: ${onsetEnvelope.length} frames`);
        
        // Step 2: Calculate inter-onset intervals
        const intervals = calculateInterOnsetIntervals(onsetEnvelope, sampleRate);
        log(`Found ${intervals.length} inter-onset intervals`);
        
        // Step 3: Build beat histogram
        const histogram = buildBeatHistogram(intervals, sampleRate);
        
        // Step 4: Find tempo from histogram peaks
        const tempoCandidates = findTempoPeaks(histogram);
        log(`Tempo candidates: ${tempoCandidates.map(t => t.bpm.toFixed(1)).join(', ')}`);
        
        // Step 5: Select most likely tempo
        const finalBPM = selectBestTempo(tempoCandidates, intervals);
        const confidence = calculateTempoConfidence(tempoCandidates, finalBPM);
        
        log(`Final BPM: ${finalBPM}, Confidence: ${confidence.toFixed(1)}%`);
        
        return {
            bpm: finalBPM,
            confidence: confidence,
            method: 'Beat Histogram + Tempo Induction',
            candidates: tempoCandidates.slice(0, 3).map(t => t.bpm)
        };
    }

    function extractOnsetEnvelope(data, sampleRate) {
        // Use spectral flux for onset detection
        const fftSize = 2048;
        const hopSize = 441; // ~10ms at 44.1kHz
        const numFrames = Math.floor((data.length - fftSize) / hopSize);
        
        const envelope = new Float32Array(numFrames);
        let prevSpectrum = null;
        
        for (let i = 0; i < numFrames; i++) {
            const start = i * hopSize;
            const frame = data.slice(start, start + fftSize);
            
            // Apply Hann window
            const windowed = new Float32Array(fftSize);
            for (let j = 0; j < fftSize; j++) {
                windowed[j] = frame[j] * (0.5 - 0.5 * Math.cos(2 * Math.PI * j / fftSize));
            }
            
            // Compute power spectrum
            const spectrum = computePowerSpectrum(windowed);
            
            // Calculate spectral flux
            if (prevSpectrum) {
                let flux = 0;
                for (let j = 0; j < spectrum.length; j++) {
                    const diff = spectrum[j] - prevSpectrum[j];
                    flux += diff > 0 ? diff : 0; // Half-wave rectification
                }
                envelope[i] = flux;
            }
            
            prevSpectrum = spectrum;
        }
        
        // Normalize
        const max = Math.max(...envelope);
        if (max > 0) {
            for (let i = 0; i < envelope.length; i++) {
                envelope[i] /= max;
            }
        }
        
        return envelope;
    }

    function computePowerSpectrum(signal) {
        const N = signal.length;
        const spectrum = new Float32Array(N / 2);
        
        // Simple DFT for lower frequencies (0-5kHz is sufficient for beat detection)
        const maxBin = Math.floor(N * 5000 / 44100);
        
        for (let k = 0; k < maxBin; k++) {
            let real = 0;
            let imag = 0;
            
            for (let n = 0; n < N; n++) {
                const angle = -2 * Math.PI * k * n / N;
                real += signal[n] * Math.cos(angle);
                imag += signal[n] * Math.sin(angle);
            }
            
            spectrum[k] = (real * real + imag * imag) / N;
        }
        
        return spectrum;
    }

    function calculateInterOnsetIntervals(envelope, sampleRate) {
        const hopSize = 441;
        const threshold = 0.15; // Adaptive threshold
        const minDistance = Math.floor(0.15 * sampleRate / hopSize); // Min 150ms between onsets
        
        // Find peaks
        const peaks = [];
        for (let i = minDistance; i < envelope.length - minDistance; i++) {
            if (envelope[i] > threshold) {
                let isPeak = true;
                for (let j = -minDistance; j <= minDistance; j++) {
                    if (j !== 0 && envelope[i + j] >= envelope[i]) {
                        isPeak = false;
                        break;
                    }
                }
                if (isPeak) {
                    peaks.push(i);
                }
            }
        }
        
        // Calculate intervals
        const intervals = [];
        for (let i = 1; i < peaks.length; i++) {
            const intervalFrames = peaks[i] - peaks[i - 1];
            const intervalSeconds = intervalFrames * hopSize / sampleRate;
            intervals.push(intervalSeconds);
        }
        
        return intervals;
    }

    function buildBeatHistogram(intervals, sampleRate) {
        // Build histogram of BPM values
        const minBPM = 60;
        const maxBPM = 200;
        const numBins = (maxBPM - minBPM) * 2; // 0.5 BPM resolution
        const histogram = new Float32Array(numBins);
        
        for (const interval of intervals) {
            const bpm = 60 / interval;
            
            // Add to histogram (with Gaussian smoothing)
            const binIdx = Math.floor((bpm - minBPM) * 2);
            if (binIdx >= 0 && binIdx < numBins) {
                // Spread energy to nearby bins
                for (let i = -2; i <= 2; i++) {
                    const idx = binIdx + i;
                    if (idx >= 0 && idx < numBins) {
                        const weight = Math.exp(-i * i / 2);
                        histogram[idx] += weight;
                    }
                }
            }
        }
        
        return histogram;
    }

    function findTempoPeaks(histogram) {
        const minBPM = 60;
        const peaks = [];
        
        // Find local maxima
        for (let i = 5; i < histogram.length - 5; i++) {
            if (histogram[i] > 0) {
                let isPeak = true;
                for (let j = -5; j <= 5; j++) {
                    if (j !== 0 && histogram[i + j] >= histogram[i]) {
                        isPeak = false;
                        break;
                    }
                }
                
                if (isPeak) {
                    const bpm = minBPM + i / 2;
                    peaks.push({
                        bpm: bpm,
                        strength: histogram[i]
                    });
                }
            }
        }
        
        // Sort by strength
        peaks.sort((a, b) => b.strength - a.strength);
        
        return peaks;
    }

    function selectBestTempo(candidates, intervals) {
        if (candidates.length === 0) return 128;
        
        // Check for metrical relationships (2:1, 3:1, etc.)
        const strongest = candidates[0].bpm;
        
        // Look for double or half tempo
        for (const candidate of candidates) {
            const ratio = candidate.bpm / strongest;
            if (Math.abs(ratio - 2) < 0.05 || Math.abs(ratio - 0.5) < 0.05) {
                // Prefer the tempo in typical trance range (125-145)
                if (strongest >= 125 && strongest <= 145) {
                    return Math.round(strongest);
                } else if (candidate.bpm >= 125 && candidate.bpm <= 145) {
                    return Math.round(candidate.bpm);
                }
            }
        }
        
        return Math.round(strongest);
    }

    function calculateTempoConfidence(candidates, finalBPM) {
        if (candidates.length === 0) return 0;
        
        const strongest = candidates[0].strength;
        let totalStrength = 0;
        let matchingStrength = 0;
        
        for (const candidate of candidates) {
            totalStrength += candidate.strength;
            
            // Count as matching if within 1 BPM or octave relationship
            if (Math.abs(candidate.bpm - finalBPM) <= 1 ||
                Math.abs(candidate.bpm - finalBPM * 2) <= 2 ||
                Math.abs(candidate.bpm - finalBPM / 2) <= 1) {
                matchingStrength += candidate.strength;
            }
        }
        
        const confidence = (matchingStrength / totalStrength) * 100;
        return Math.min(95, confidence);
    }

    // ===== PRECISION KEY DETECTION =====
    // Using enhanced chromagram with proper FFT and harmonic weighting
    async function detectKeyPrecision(buffer) {
        const sampleRate = buffer.sampleRate;
        const channelData = buffer.getChannelData(0);
        
        log('Starting precision key detection...');
        
        // Step 1: Calculate high-resolution chromagram
        const chromagram = calculatePrecisionChromagram(channelData, sampleRate);
        log(`Chromagram: ${chromagram.map(v => v.toFixed(3)).join(', ')}`);
        
        // Step 2: Apply Krumhansl-Schmuckler algorithm
        const keyResults = applyKSAlgorithm(chromagram);
        
        // Step 3: Verify with harmonic product spectrum
        const hpsKey = detectKeyHPS(channelData, sampleRate);
        log(`K-S top result: ${keyResults[0].key} (${keyResults[0].correlation.toFixed(3)})`);
        log(`HPS result: ${hpsKey.key}`);
        
        // Combine results
        const finalKey = keyResults[0].key;
        const confidence = keyResults[0].correlation * 100;
        
        return {
            key: finalKey,
            confidence: confidence,
            method: 'K-S + Harmonic Product Spectrum',
            candidates: keyResults.slice(0, 2).map(r => r.key)
        };
    }

    function calculatePrecisionChromagram(data, sampleRate) {
        const chromagram = new Array(12).fill(0);
        const fftSize = 16384; // Large FFT for high frequency resolution
        const hopSize = fftSize / 4;
        const numAnalyze = Math.min(20, Math.floor((data.length - fftSize) / hopSize));
        
        // Analyze multiple windows across the track
        for (let win = 0; win < numAnalyze; win++) {
            const start = Math.floor(win * (data.length - fftSize) / numAnalyze);
            const segment = data.slice(start, start + fftSize);
            
            // Apply Blackman-Harris window for better frequency resolution
            const windowed = new Float32Array(fftSize);
            for (let i = 0; i < fftSize; i++) {
                const a0 = 0.35875;
                const a1 = 0.48829;
                const a2 = 0.14128;
                const a3 = 0.01168;
                windowed[i] = segment[i] * (
                    a0 -
                    a1 * Math.cos(2 * Math.PI * i / fftSize) +
                    a2 * Math.cos(4 * Math.PI * i / fftSize) -
                    a3 * Math.cos(6 * Math.PI * i / fftSize)
                );
            }
            
            // Calculate pitch classes using precise frequency bins
            const pitchClasses = calculatePitchClassesFFT(windowed, sampleRate);
            
            for (let i = 0; i < 12; i++) {
                chromagram[i] += pitchClasses[i];
            }
        }
        
        // Normalize
        const sum = chromagram.reduce((a, b) => a + b, 0);
        if (sum > 0) {
            for (let i = 0; i < 12; i++) {
                chromagram[i] /= sum;
            }
        }
        
        // Apply harmonic weighting (emphasize 3rd and 5th)
        const weighted = new Array(12).fill(0);
        for (let i = 0; i < 12; i++) {
            weighted[i] = chromagram[i] * 1.0; // Tonic
            weighted[(i + 3) % 12] += chromagram[i] * 0.4; // Minor 3rd
            weighted[(i + 4) % 12] += chromagram[i] * 0.4; // Major 3rd
            weighted[(i + 7) % 12] += chromagram[i] * 0.6; // Perfect 5th
        }
        
        // Normalize again
        const wSum = weighted.reduce((a, b) => a + b, 0);
        if (wSum > 0) {
            for (let i = 0; i < 12; i++) {
                weighted[i] /= wSum;
            }
        }
        
        return weighted;
    }

    function calculatePitchClassesFFT(signal, sampleRate) {
        const N = signal.length;
        const pitchClasses = new Array(12).fill(0);
        
        // For each pitch class, sum energy from relevant frequency bins
        for (let pc = 0; pc < 12; pc++) {
            let energy = 0;
            
            // Check octaves from C1 to C7
            for (let octave = 1; octave <= 7; octave++) {
                const freq = 440 * Math.pow(2, (pc - 9) / 12 + (octave - 4));
                
                if (freq < 30 || freq > sampleRate / 2) continue;
                
                // Find corresponding FFT bin
                const binFloat = N * freq / sampleRate;
                const bin = Math.round(binFloat);
                
                if (bin >= 0 && bin < N / 2) {
                    // Use Goertzel algorithm for precise frequency
                    const magnitude = goertzelMagnitude(signal, freq, sampleRate);
                    
                    // Weight middle octaves more (C3-C5 for trance music)
                    const octaveWeight = (octave >= 3 && octave <= 5) ? 2.0 : 1.0;
                    energy += magnitude * octaveWeight;
                }
            }
            
            pitchClasses[pc] = energy;
        }
        
        // Normalize
        const max = Math.max(...pitchClasses);
        if (max > 0) {
            for (let i = 0; i < 12; i++) {
                pitchClasses[i] /= max;
            }
        }
        
        return pitchClasses;
    }

    function goertzelMagnitude(signal, targetFreq, sampleRate) {
        const N = signal.length;
        const k = Math.round(N * targetFreq / sampleRate);
        const omega = 2 * Math.PI * k / N;
        const coeff = 2 * Math.cos(omega);
        
        let s0, s1 = 0, s2 = 0;
        
        for (let n = 0; n < N; n++) {
            s0 = signal[n] + coeff * s1 - s2;
            s2 = s1;
            s1 = s0;
        }
        
        const real = s1 - s2 * Math.cos(omega);
        const imag = s2 * Math.sin(omega);
        
        return Math.sqrt(real * real + imag * imag) / N;
    }

    function applyKSAlgorithm(chromagram) {
        const results = [];
        
        // Test all 24 keys
        for (let tonic = 0; tonic < 12; tonic++) {
            // Major key
            const majorCorr = calculateKSCorrelation(chromagram, KEY_PROFILES.major, tonic);
            results.push({
                key: `${NOTE_NAMES[tonic]} major`,
                correlation: majorCorr,
                tonic: NOTE_NAMES[tonic],
                mode: 'major'
            });
            
            // Minor key
            const minorCorr = calculateKSCorrelation(chromagram, KEY_PROFILES.minor, tonic);
            const tonicName = [3, 8, 10].includes(tonic) ? NOTE_NAMES_FLAT[tonic] : NOTE_NAMES[tonic];
            results.push({
                key: `${tonicName} minor`,
                correlation: minorCorr,
                tonic: tonicName,
                mode: 'minor'
            });
        }
        
        // Sort by correlation
        results.sort((a, b) => b.correlation - a.correlation);
        
        return results;
    }

    function calculateKSCorrelation(observed, profile, shift) {
        const n = 12;
        const rotated = [...profile.slice(shift), ...profile.slice(0, shift)];
        
        // Calculate means
        const meanObs = observed.reduce((a, b) => a + b, 0) / n;
        const meanProf = rotated.reduce((a, b) => a + b, 0) / n;
        
        // Calculate correlation
        let numerator = 0;
        let sumSqObs = 0;
        let sumSqProf = 0;
        
        for (let i = 0; i < n; i++) {
            const diffObs = observed[i] - meanObs;
            const diffProf = rotated[i] - meanProf;
            numerator += diffObs * diffProf;
            sumSqObs += diffObs * diffObs;
            sumSqProf += diffProf * diffProf;
        }
        
        const denominator = Math.sqrt(sumSqObs * sumSqProf);
        return denominator === 0 ? 0 : numerator / denominator;
    }

    function detectKeyHPS(data, sampleRate) {
        // Harmonic Product Spectrum for fundamental frequency detection
        const fftSize = 8192;
        const segment = data.slice(0, Math.min(fftSize, data.length));
        
        // Window
        const windowed = new Float32Array(segment.length);
        for (let i = 0; i < segment.length; i++) {
            windowed[i] = segment[i] * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / segment.length));
        }
        
        // Compute spectrum
        const spectrum = computePowerSpectrum(windowed);
        
        // Apply HPS
        const hpsSpectrum = new Float32Array(spectrum.length / 4);
        for (let i = 0; i < hpsSpectrum.length; i++) {
            hpsSpectrum[i] = spectrum[i] * spectrum[i * 2] * spectrum[i * 3] * spectrum[i * 4];
        }
        
        // Find peak
        let maxIdx = 0;
        let maxVal = hpsSpectrum[0];
        for (let i = 1; i < hpsSpectrum.length; i++) {
            if (hpsSpectrum[i] > maxVal) {
                maxVal = hpsSpectrum[i];
                maxIdx = i;
            }
        }
        
        // Convert to pitch class
        const freq = maxIdx * sampleRate / fftSize;
        const midiNote = 12 * Math.log2(freq / 440) + 69;
        const pitchClass = Math.round(midiNote) % 12;
        
        return {
            key: `${NOTE_NAMES[pitchClass]} major`,
            pitchClass: pitchClass
        };
    }

    function getCamelotCode(key) {
        if (CAMELOT_WHEEL[key]) {
            return CAMELOT_WHEEL[key];
        }
        
        const normalized = key.replace('D#', 'Eb').replace('G#', 'Ab').replace('A#', 'Bb');
        if (CAMELOT_WHEEL[normalized]) {
            return CAMELOT_WHEEL[normalized];
        }
        
        const [note, mode] = key.split(' ');
        let noteIndex = NOTE_NAMES.indexOf(note);
        if (noteIndex === -1) noteIndex = NOTE_NAMES_FLAT.indexOf(note);
        if (noteIndex === -1) return '?';
        
        const offset = mode === 'major' ? 8 : 5;
        const camelotNumber = ((noteIndex + offset) % 12) || 12;
        const camelotLetter = mode === 'major' ? 'B' : 'A';
        
        return `${camelotNumber}${camelotLetter}`;
    }

    function displayResults(bpmResult, keyResult, duration) {
        document.getElementById('bpmValue').textContent = bpmResult.bpm;
        const candidatesText = bpmResult.candidates && bpmResult.candidates.length > 1 
            ? `Candidates: ${bpmResult.candidates.map(b => Math.round(b)).join(', ')}`
            : '';
        document.getElementById('bpmCandidates').textContent = candidatesText;
        document.getElementById('bpmConfidence').style.width = bpmResult.confidence + '%';
        document.getElementById('bpmConfidenceText').textContent = `${Math.round(bpmResult.confidence)}% confidence`;
        document.getElementById('bpmMethod').textContent = bpmResult.method;
        
        document.getElementById('keyValue').textContent = keyResult.key;
        const keyCandidatesText = keyResult.candidates && keyResult.candidates.length > 1 && keyResult.candidates[0] !== keyResult.candidates[1]
            ? `Runner-up: ${keyResult.candidates[1]}`
            : '';
        document.getElementById('keyCandidates').textContent = keyCandidatesText;
        document.getElementById('keyConfidence').style.width = keyResult.confidence + '%';
        document.getElementById('keyConfidenceText').textContent = `${Math.round(keyResult.confidence)}% confidence`;
        document.getElementById('keyMethod').textContent = keyResult.method;
        
        const camelotCode = getCamelotCode(keyResult.key);
        document.getElementById('positionCode').textContent = camelotCode;
        document.getElementById('positionKey').textContent = keyResult.key;
        document.getElementById('camelotDetail').textContent = `${camelotCode} (${keyResult.key})`;
        document.getElementById('durationAnalyzed').textContent = `${duration.toFixed(1)}s`;
        
        const compatible = getCompatibleKeys(camelotCode);
        const compatibleKeysDiv = document.getElementById('compatibleKeys');
        compatibleKeysDiv.innerHTML = compatible.map((k, idx) => {
            const keyName = CAMELOT_TO_KEY[k] || k;
            const isPerfect = idx === 0;
            return `<div class="key-tag ${isPerfect ? 'perfect' : ''}">${k} ‚Äî ${keyName}</div>`;
        }).join('');
        
        const debugInfo = document.getElementById('debugInfo');
        debugInfo.textContent = debugLog.join('\n');
        debugInfo.classList.add('active');
        
        drawCamelotWheel(camelotCode);
        showResults();
    }

    function getCompatibleKeys(camelotCode) {
        if (camelotCode === '?') return [];
        
        const num = parseInt(camelotCode);
        const letter = camelotCode.slice(-1);
        
        const compatible = [];
        compatible.push(num + (letter === 'A' ? 'B' : 'A'));
        compatible.push((num === 12 ? 1 : num + 1) + letter);
        compatible.push((num === 1 ? 12 : num - 1) + letter);
        
        return compatible;
    }

    function drawCamelotWheel(currentCode) {
        const outerRing = document.getElementById('outerRing');
        const innerRing = document.getElementById('innerRing');
        
        outerRing.innerHTML = '';
        innerRing.innerHTML = '';
        
        const colors = [
            '#ff006e', '#ff4d6d', '#ff7aa2', '#ffa6c1', '#ffccd5',
            '#00f5ff', '#00d9ff', '#00bfff', '#0099ff', '#0066ff',
            '#6a4c93', '#9c89b8'
        ];
        
        for (let i = 0; i < 12; i++) {
            const angle = (i * 30 - 90) * Math.PI / 180;
            const xOuter = 150 + 110 * Math.cos(angle);
            const yOuter = 150 + 110 * Math.sin(angle);
            const xInner = 150 + 70 * Math.cos(angle);
            const yInner = 150 + 70 * Math.sin(angle);
            
            const codeB = (i === 0 ? 12 : i) + 'B';
            const codeA = (i === 0 ? 12 : i) + 'A';
            
            const circleB = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleB.setAttribute('cx', xOuter);
            circleB.setAttribute('cy', yOuter);
            circleB.setAttribute('r', codeB === currentCode ? 24 : 16);
            circleB.setAttribute('fill', colors[i]);
            circleB.setAttribute('opacity', codeB === currentCode ? 1 : 0.5);
            circleB.setAttribute('stroke', codeB === currentCode ? 'var(--accent-primary)' : 'none');
            circleB.setAttribute('stroke-width', codeB === currentCode ? 3 : 0);
            if (codeB === currentCode) {
                circleB.style.filter = 'drop-shadow(0 0 10px var(--accent-primary))';
            }
            outerRing.appendChild(circleB);
            
            const circleA = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleA.setAttribute('cx', xInner);
            circleA.setAttribute('cy', yInner);
            circleA.setAttribute('r', codeA === currentCode ? 22 : 14);
            circleA.setAttribute('fill', colors[i]);
            circleA.setAttribute('opacity', codeA === currentCode ? 1 : 0.4);
            circleA.setAttribute('stroke', codeA === currentCode ? 'var(--accent-primary)' : 'none');
            circleA.setAttribute('stroke-width', codeA === currentCode ? 3 : 0);
            if (codeA === currentCode) {
                circleA.style.filter = 'drop-shadow(0 0 10px var(--accent-primary))';
            }
            innerRing.appendChild(circleA);
        }
    }

    function showAnalyzing() {
        document.getElementById('analyzing').classList.add('active');
    }

    function hideAnalyzing() {
        document.getElementById('analyzing').classList.remove('active');
    }

    function showResults() {
        document.getElementById('results').classList.add('active');
        document.getElementById('resultsCard').classList.add('active');
    }

    function hideResults() {
        document.getElementById('results').classList.remove('active');
        document.getElementById('resultsCard').classList.remove('active');
    }

    function showError(message) {
        const errorDiv = document.getElementById('error');
        errorDiv.textContent = message;
        errorDiv.classList.add('active');
    }

    function hideError() {
        document.getElementById('error').classList.remove('active');
    }

    drawCamelotWheel('8B');
</script>
```

</body>
</html>

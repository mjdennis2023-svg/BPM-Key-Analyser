<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Harmonic Analyzer">
    <title>Harmonic Analyzer Pro</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=JetBrains+Mono:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e1a;
            --bg-secondary: #12182b;
            --bg-tertiary: #1a2235;
            --accent-primary: #00f0ff;
            --accent-secondary: #ff00ea;
            --accent-tertiary: #00ff88;
            --text-primary: #ffffff;
            --text-secondary: #8b95b8;
            --text-muted: #4a5578;
            --surface: rgba(26, 34, 53, 0.6);
            --surface-elevated: rgba(26, 34, 53, 0.9);
            --glow-cyan: rgba(0, 240, 255, 0.3);
            --glow-magenta: rgba(255, 0, 234, 0.3);
        }

```
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
    }

    body {
        font-family: 'JetBrains Mono', monospace;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
        overflow-x: hidden;
        position: relative;
    }

    body::before {
        content: '';
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: 
            radial-gradient(circle at 20% 30%, var(--glow-cyan) 0%, transparent 50%),
            radial-gradient(circle at 80% 70%, var(--glow-magenta) 0%, transparent 50%);
        pointer-events: none;
        z-index: 0;
        opacity: 0.15;
    }

    .grain {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0.03;
        pointer-events: none;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        z-index: 1;
    }

    .container {
        position: relative;
        z-index: 2;
        max-width: 1400px;
        margin: 0 auto;
        padding: 40px 20px;
    }

    .header {
        text-align: center;
        margin-bottom: 60px;
        animation: slideDown 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @keyframes slideDown {
        from {
            opacity: 0;
            transform: translateY(-30px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .logo {
        font-family: 'Orbitron', sans-serif;
        font-size: 48px;
        font-weight: 900;
        letter-spacing: -2px;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        margin-bottom: 8px;
        text-transform: uppercase;
        position: relative;
        display: inline-block;
    }

    .logo::after {
        content: '';
        position: absolute;
        bottom: -8px;
        left: 50%;
        transform: translateX(-50%);
        width: 60%;
        height: 2px;
        background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
    }

    .tagline {
        font-size: 13px;
        letter-spacing: 3px;
        color: var(--text-secondary);
        text-transform: uppercase;
        font-weight: 300;
    }

    .badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        background: var(--surface-elevated);
        border: 1px solid rgba(0, 240, 255, 0.3);
        padding: 6px 16px;
        border-radius: 20px;
        font-size: 11px;
        margin-top: 16px;
        color: var(--accent-primary);
        font-weight: 500;
        backdrop-filter: blur(10px);
    }

    .badge::before {
        content: '‚óè';
        animation: pulse-dot 2s ease-in-out infinite;
    }

    @keyframes pulse-dot {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.5; transform: scale(0.8); }
    }

    .grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-bottom: 30px;
    }

    @media (max-width: 968px) {
        .grid {
            grid-template-columns: 1fr;
        }
    }

    .card {
        background: var(--surface);
        backdrop-filter: blur(20px);
        border-radius: 24px;
        border: 1px solid rgba(255, 255, 255, 0.05);
        padding: 32px;
        position: relative;
        overflow: hidden;
        animation: fadeInUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) backwards;
    }

    .card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 1px;
        background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
        opacity: 0.5;
    }

    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .card:nth-child(1) { animation-delay: 0.1s; }
    .card:nth-child(2) { animation-delay: 0.2s; }
    .card:nth-child(3) { animation-delay: 0.3s; }

    .card-title {
        font-family: 'Orbitron', sans-serif;
        font-size: 18px;
        font-weight: 700;
        margin-bottom: 24px;
        color: var(--text-primary);
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .control-panel {
        text-align: center;
    }

    .btn {
        font-family: 'JetBrains Mono', monospace;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
        border: none;
        padding: 20px 48px;
        font-size: 15px;
        font-weight: 700;
        border-radius: 50px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 12px;
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 10px 40px rgba(0, 240, 255, 0.3);
        position: relative;
        overflow: hidden;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, var(--accent-secondary), var(--accent-primary));
        opacity: 0;
        transition: opacity 0.3s;
    }

    .btn:hover::before {
        opacity: 1;
    }

    .btn span {
        position: relative;
        z-index: 1;
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 15px 50px rgba(0, 240, 255, 0.5);
    }

    .btn:active {
        transform: translateY(0);
    }

    .btn.stop {
        background: linear-gradient(135deg, #ff0055, #ff4488);
        box-shadow: 0 10px 40px rgba(255, 0, 85, 0.3);
    }

    .btn.stop::before {
        background: linear-gradient(135deg, #ff4488, #ff0055);
    }

    .btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
    }

    .recording-status {
        margin-top: 24px;
        padding: 20px;
        background: rgba(0, 240, 255, 0.05);
        border: 1px solid rgba(0, 240, 255, 0.2);
        border-radius: 16px;
        display: none;
    }

    .recording-status.active {
        display: block;
        animation: fadeInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .rec-indicator {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-bottom: 12px;
    }

    .rec-dot {
        width: 12px;
        height: 12px;
        background: #ff0055;
        border-radius: 50%;
        box-shadow: 0 0 20px rgba(255, 0, 85, 0.8);
        animation: pulse-rec 1.5s ease-in-out infinite;
    }

    @keyframes pulse-rec {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.3); opacity: 0.7; }
    }

    .rec-time {
        font-family: 'Orbitron', sans-serif;
        font-size: 24px;
        font-weight: 700;
        color: var(--accent-primary);
    }

    .rec-hint {
        font-size: 11px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .analyzing {
        text-align: center;
        padding: 40px;
        display: none;
    }

    .analyzing.active {
        display: block;
    }

    .spinner {
        width: 60px;
        height: 60px;
        margin: 0 auto 24px;
        border: 3px solid rgba(0, 240, 255, 0.1);
        border-top: 3px solid var(--accent-primary);
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .analyzing-text {
        font-family: 'Orbitron', sans-serif;
        font-size: 16px;
        color: var(--accent-primary);
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .analyzing-step {
        font-size: 12px;
        color: var(--text-secondary);
    }

    .results {
        display: none;
    }

    .results.active {
        display: block;
    }

    .metrics {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 32px;
    }

    .metric {
        background: var(--bg-secondary);
        border: 1px solid rgba(0, 240, 255, 0.1);
        border-radius: 20px;
        padding: 28px;
        position: relative;
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .metric:hover {
        border-color: rgba(0, 240, 255, 0.3);
        transform: translateY(-2px);
    }

    .metric::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        width: 100px;
        height: 100px;
        background: radial-gradient(circle, var(--glow-cyan) 0%, transparent 70%);
        opacity: 0.1;
        pointer-events: none;
    }

    .metric-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-muted);
        margin-bottom: 12px;
        font-weight: 500;
    }

    .metric-value {
        font-family: 'Orbitron', sans-serif;
        font-size: 48px;
        font-weight: 900;
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        line-height: 1;
        margin-bottom: 8px;
    }

    .metric-sub {
        font-size: 11px;
        color: var(--text-secondary);
        min-height: 16px;
    }

    .confidence-bar {
        margin-top: 16px;
        height: 4px;
        background: rgba(0, 240, 255, 0.1);
        border-radius: 2px;
        overflow: hidden;
        position: relative;
    }

    .confidence-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--accent-primary), var(--accent-tertiary));
        border-radius: 2px;
        transition: width 1s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 0 10px var(--accent-primary);
    }

    .confidence-text {
        font-size: 10px;
        color: var(--text-muted);
        margin-top: 8px;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    .camelot-section {
        margin: 32px 0;
    }

    .camelot-title {
        text-align: center;
        font-family: 'Orbitron', sans-serif;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-secondary);
        margin-bottom: 24px;
    }

    .wheel-container {
        position: relative;
        width: 320px;
        height: 320px;
        margin: 0 auto;
    }

    .wheel-svg {
        width: 100%;
        height: 100%;
        filter: drop-shadow(0 10px 40px rgba(0, 240, 255, 0.2));
    }

    .current-position {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
        width: 100px;
        height: 100px;
        border-radius: 50%;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-weight: 700;
        box-shadow: 0 10px 40px rgba(0, 240, 255, 0.5);
        border: 3px solid var(--bg-primary);
    }

    .position-code {
        font-family: 'Orbitron', sans-serif;
        font-size: 32px;
        font-weight: 900;
    }

    .position-key {
        font-size: 12px;
        opacity: 0.8;
        margin-top: 4px;
    }

    .compatible-section {
        margin: 32px 0;
        padding: 24px;
        background: var(--bg-secondary);
        border: 1px solid rgba(0, 240, 255, 0.1);
        border-radius: 20px;
    }

    .section-title {
        font-family: 'Orbitron', sans-serif;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: var(--text-secondary);
        margin-bottom: 16px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .key-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
    }

    .key-tag {
        background: rgba(0, 240, 255, 0.1);
        border: 1px solid rgba(0, 240, 255, 0.3);
        padding: 12px 20px;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 500;
        color: var(--accent-primary);
        transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        cursor: default;
    }

    .key-tag:hover {
        background: rgba(0, 240, 255, 0.2);
        transform: translateY(-2px);
    }

    .key-tag.perfect {
        background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
        color: var(--bg-primary);
        border-color: transparent;
        font-weight: 700;
    }

    .details-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
    }

    .detail-row {
        display: flex;
        justify-content: space-between;
        padding: 12px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 8px;
        font-size: 12px;
    }

    .detail-label {
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 10px;
    }

    .detail-value {
        color: var(--accent-primary);
        font-weight: 500;
    }

    .audio-player {
        width: 100%;
        margin-top: 24px;
        border-radius: 12px;
        filter: saturate(0) brightness(0.8) contrast(1.2);
    }

    .debug-panel {
        margin-top: 24px;
        padding: 16px;
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(0, 240, 255, 0.1);
        border-radius: 12px;
        font-family: 'JetBrains Mono', monospace;
        font-size: 10px;
        color: var(--text-secondary);
        max-height: 200px;
        overflow-y: auto;
        line-height: 1.6;
        display: none;
    }

    .debug-panel.active {
        display: block;
    }

    .error {
        background: rgba(255, 0, 85, 0.1);
        border: 1px solid rgba(255, 0, 85, 0.3);
        color: #ff4488;
        padding: 16px;
        border-radius: 12px;
        margin-top: 16px;
        font-size: 13px;
        display: none;
    }

    .error.active {
        display: block;
        animation: fadeInUp 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @media (max-width: 768px) {
        .logo {
            font-size: 36px;
        }

        .metrics {
            grid-template-columns: 1fr;
        }

        .details-grid {
            grid-template-columns: 1fr;
        }

        .wheel-container {
            width: 280px;
            height: 280px;
        }
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
        width: 8px;
    }

    ::-webkit-scrollbar-track {
        background: var(--bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
        background: var(--accent-primary);
        border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: var(--accent-secondary);
    }
</style>
```

</head>
<body>
    <div class="grain"></div>

```
<div class="container">
    <header class="header">
        <h1 class="logo">Harmonic</h1>
        <p class="tagline">Professional Audio Analysis</p>
        <span class="badge">Enhanced Trance/EDM Detection</span>
    </header>

    <div class="grid">
        <div class="card control-panel">
            <h2 class="card-title">Live Capture</h2>
            <p style="color: var(--text-secondary); margin-bottom: 24px; font-size: 13px;">
                Play a track and analyze through your microphone
            </p>

            <div id="recordingControls">
                <button class="btn" id="startBtn">
                    <span>üé§</span>
                    <span>Start Listening</span>
                </button>
                <button class="btn stop" id="stopBtn" style="display: none;">
                    <span>‚èπ</span>
                    <span>Stop & Analyze</span>
                </button>
            </div>

            <div class="recording-status" id="recordingStatus">
                <div class="rec-indicator">
                    <div class="rec-dot"></div>
                    <div class="rec-time" id="recordingTime">0:00</div>
                </div>
                <p class="rec-hint">Recording ‚Äî 20s minimum recommended</p>
            </div>

            <div class="analyzing" id="analyzing">
                <div class="spinner"></div>
                <p class="analyzing-text">Analyzing</p>
                <p class="analyzing-step" id="analyzingStep">Processing audio...</p>
            </div>

            <div class="error" id="error"></div>
        </div>

        <div class="card results" id="resultsCard">
            <h2 class="card-title">Detection Results</h2>
            
            <div class="metrics">
                <div class="metric">
                    <div class="metric-label">BPM</div>
                    <div class="metric-value" id="bpmValue">--</div>
                    <div class="metric-sub" id="bpmCandidates"></div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="bpmConfidence" style="width: 0%"></div>
                    </div>
                    <div class="confidence-text" id="bpmConfidenceText"></div>
                </div>
                
                <div class="metric">
                    <div class="metric-label">Musical Key</div>
                    <div class="metric-value" id="keyValue" style="font-size: 32px;">--</div>
                    <div class="metric-sub" id="keyCandidates"></div>
                    <div class="confidence-bar">
                        <div class="confidence-fill" id="keyConfidence" style="width: 0%"></div>
                    </div>
                    <div class="confidence-text" id="keyConfidenceText"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="card results" id="results" style="animation-delay: 0.4s;">
        <div class="camelot-section">
            <h3 class="camelot-title">Camelot Wheel Position</h3>
            <div class="wheel-container">
                <svg class="wheel-svg" viewBox="0 0 300 300">
                    <g id="outerRing"></g>
                    <g id="innerRing"></g>
                </svg>
                <div class="current-position" id="currentPosition">
                    <div class="position-code" id="positionCode">--</div>
                    <div class="position-key" id="positionKey">--</div>
                </div>
            </div>
        </div>

        <div class="compatible-section">
            <h3 class="section-title">
                <span>‚ú®</span>
                <span>Compatible Mixing Keys</span>
            </h3>
            <div class="key-tags" id="compatibleKeys"></div>
        </div>

        <div class="compatible-section">
            <h3 class="section-title">
                <span>üìä</span>
                <span>Analysis Details</span>
            </h3>
            <div class="details-grid">
                <div class="detail-row">
                    <span class="detail-label">Key Method</span>
                    <span class="detail-value" id="keyMethod">--</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">BPM Method</span>
                    <span class="detail-value" id="bpmMethod">--</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Camelot</span>
                    <span class="detail-value" id="camelotDetail">--</span>
                </div>
                <div class="detail-row">
                    <span class="detail-label">Duration</span>
                    <span class="detail-value" id="durationAnalyzed">--</span>
                </div>
            </div>
        </div>

        <audio id="audioPlayer" class="audio-player" controls></audio>

        <div class="debug-panel" id="debugInfo"></div>
    </div>
</div>

<script>
    // PROFESSIONAL CAMELOT WHEEL MAPPING
    const CAMELOT_WHEEL = {
        'C major': '8B', 'Db major': '3B', 'D major': '10B', 'Eb major': '5B',
        'E major': '12B', 'F major': '7B', 'F# major': '2B', 'Gb major': '2B',
        'G major': '9B', 'Ab major': '4B', 'A major': '11B', 'Bb major': '6B', 'B major': '1B',
        'C minor': '5A', 'C# minor': '12A', 'D minor': '7A', 'D# minor': '2A', 'Eb minor': '2A',
        'E minor': '9A', 'F minor': '4A', 'F# minor': '11A', 'G minor': '6A',
        'G# minor': '1A', 'Ab minor': '1A', 'A minor': '8A', 'A# minor': '3A', 'Bb minor': '3A', 'B minor': '10A'
    };

    const CAMELOT_TO_KEY = Object.fromEntries(
        Object.entries(CAMELOT_WHEEL).map(([key, camelot]) => [camelot, key])
    );

    const KEY_PROFILES = {
        major: [6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88],
        minor: [6.33, 2.68, 3.52, 5.38, 2.60, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17]
    };

    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const NOTE_NAMES_FLAT = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

    let audioContext;
    let mediaRecorder;
    let audioChunks = [];
    let recordingStartTime;
    let recordingInterval;
    let stream;
    let debugLog = [];

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const recordingStatus = document.getElementById('recordingStatus');
    const recordingTime = document.getElementById('recordingTime');

    startBtn.addEventListener('click', startRecording);
    stopBtn.addEventListener('click', stopRecording);

    function log(msg) {
        debugLog.push(msg);
        console.log(msg);
    }

    async function startRecording() {
        try {
            debugLog = [];
            hideError();
            hideResults();
            
            stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false,
                    sampleRate: 44100
                } 
            });

            audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 44100 });
            
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus',
                audioBitsPerSecond: 128000
            });
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                await processAudio(audioBlob);
            };

            mediaRecorder.start();
            
            startBtn.style.display = 'none';
            stopBtn.style.display = 'inline-flex';
            recordingStatus.classList.add('active');
            
            recordingStartTime = Date.now();
            recordingInterval = setInterval(updateRecordingTime, 100);

        } catch (error) {
            showError('Microphone access denied. Please allow microphone access and try again.');
            console.error('Error accessing microphone:', error);
        }
    }

    function updateRecordingTime() {
        const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        recordingTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            clearInterval(recordingInterval);
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            stopBtn.style.display = 'none';
            startBtn.style.display = 'inline-flex';
            recordingStatus.classList.remove('active');
            showAnalyzing();
        }
    }

    async function processAudio(blob) {
        try {
            updateAnalyzingStep('Decoding audio...');
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            
            log(`Audio decoded: ${audioBuffer.duration.toFixed(2)}s, ${audioBuffer.sampleRate}Hz`);

            updateAnalyzingStep('Detecting BPM with enhanced algorithms...');
            const bpmResult = await detectBPMEnhanced(audioBuffer);
            
            updateAnalyzingStep('Analyzing musical key...');
            const keyResult = await detectKeyEnhanced(audioBuffer);
            
            displayResults(bpmResult, keyResult, audioBuffer.duration);
            
            const audioPlayer = document.getElementById('audioPlayer');
            audioPlayer.src = URL.createObjectURL(blob);
            
        } catch (error) {
            showError('Error analyzing audio: ' + error.message);
            console.error('Processing error:', error);
        } finally {
            hideAnalyzing();
        }
    }

    function updateAnalyzingStep(text) {
        document.getElementById('analyzingStep').textContent = text;
    }

    async function detectBPMEnhanced(buffer) {
        const sampleRate = buffer.sampleRate;
        const channelData = buffer.getChannelData(0);
        
        log('Starting BPM detection...');
        
        const combBPM = detectBPMCombFilter(channelData, sampleRate);
        log(`Comb filter BPM: ${combBPM}`);
        
        const autocorrBPM = detectBPMAutocorrelationEnhanced(channelData, sampleRate);
        log(`Autocorrelation BPM: ${autocorrBPM}`);
        
        const peakBPM = detectBPMPeakTracking(channelData, sampleRate);
        log(`Peak tracking BPM: ${peakBPM}`);
        
        const candidates = [combBPM, autocorrBPM, peakBPM].filter(b => b > 0);
        log(`BPM candidates: ${candidates.join(', ')}`);
        
        if (candidates.length === 0) {
            return { bpm: 128, confidence: 0, method: 'Default', candidates: [] };
        }
        
        const finalBPM = selectBestBPM(candidates);
        const confidence = calculateBPMConfidence(candidates, finalBPM);
        
        log(`Final BPM: ${finalBPM}, Confidence: ${confidence}%`);
        
        return {
            bpm: finalBPM,
            confidence: confidence,
            method: 'Multi-algorithm',
            candidates: candidates
        };
    }

    function detectBPMCombFilter(data, sampleRate) {
        const minBPM = 120;
        const maxBPM = 150;
        const minPeriod = Math.floor(60 * sampleRate / maxBPM);
        const maxPeriod = Math.floor(60 * sampleRate / minBPM);
        
        const analyzeLength = Math.min(data.length, sampleRate * 30);
        
        let maxEnergy = 0;
        let bestPeriod = 0;
        
        for (let period = minPeriod; period <= maxPeriod; period++) {
            let energy = 0;
            let count = 0;
            
            for (let i = 0; i < analyzeLength - period * 4; i += period) {
                for (let j = 0; j < 4; j++) {
                    const idx = i + j * period;
                    if (idx < analyzeLength) {
                        energy += Math.abs(data[idx]);
                        count++;
                    }
                }
            }
            
            energy /= count;
            
            if (energy > maxEnergy) {
                maxEnergy = energy;
                bestPeriod = period;
            }
        }
        
        return bestPeriod > 0 ? Math.round(60 * sampleRate / bestPeriod) : 0;
    }

    function detectBPMAutocorrelationEnhanced(data, sampleRate) {
        const minBPM = 120;
        const maxBPM = 150;
        const minLag = Math.floor(60 * sampleRate / maxBPM);
        const maxLag = Math.floor(60 * sampleRate / minBPM);
        
        const downsampleFactor = 4;
        const downsampled = [];
        for (let i = 0; i < data.length; i += downsampleFactor) {
            downsampled.push(data[i]);
        }
        const dsRate = sampleRate / downsampleFactor;
        
        const analyzeLength = Math.min(downsampled.length, Math.floor(dsRate * 30));
        const dsMinLag = Math.floor(minLag / downsampleFactor);
        const dsMaxLag = Math.floor(maxLag / downsampleFactor);
        
        let maxCorr = 0;
        let bestLag = dsMinLag;
        
        for (let lag = dsMinLag; lag <= dsMaxLag; lag++) {
            let corr = 0;
            const samples = Math.min(Math.floor(dsRate * 10), analyzeLength - lag);
            
            for (let i = 0; i < samples; i++) {
                corr += downsampled[i] * downsampled[i + lag];
            }
            
            if (corr > maxCorr) {
                maxCorr = corr;
                bestLag = lag;
            }
        }
        
        const actualLag = bestLag * downsampleFactor;
        return actualLag > 0 ? Math.round(60 * sampleRate / actualLag) : 0;
    }

    function detectBPMPeakTracking(data, sampleRate) {
        const windowSize = Math.floor(sampleRate * 0.02);
        const envelope = [];
        
        for (let i = 0; i < data.length - windowSize; i += windowSize / 2) {
            let energy = 0;
            for (let j = 0; j < windowSize; j++) {
                energy += data[i + j] * data[i + j];
            }
            envelope.push(Math.sqrt(energy / windowSize));
        }
        
        const diff = [];
        for (let i = 1; i < envelope.length; i++) {
            diff.push(Math.max(0, envelope[i] - envelope[i - 1]));
        }
        
        const threshold = calculateMedian(diff) * 2;
        const peaks = [];
        const minDistance = Math.floor(60 / 150 * sampleRate / (windowSize / 2));
        
        for (let i = minDistance; i < diff.length - minDistance; i++) {
            if (diff[i] > threshold) {
                let isPeak = true;
                for (let j = i - minDistance; j < i + minDistance; j++) {
                    if (j !== i && diff[j] > diff[i]) {
                        isPeak = false;
                        break;
                    }
                }
                if (isPeak) {
                    peaks.push(i);
                }
            }
        }
        
        if (peaks.length < 8) return 0;
        
        const intervals = [];
        for (let i = 1; i < peaks.length; i++) {
            intervals.push(peaks[i] - peaks[i - 1]);
        }
        
        const medianInterval = calculateMedian(intervals);
        const timePerFrame = (windowSize / 2) / sampleRate;
        const bpm = Math.round(60 / (medianInterval * timePerFrame));
        
        return bpm;
    }

    function calculateMedian(arr) {
        if (arr.length === 0) return 0;
        const sorted = [...arr].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    }

    function selectBestBPM(candidates) {
        if (candidates.length === 0) return 128;
        if (candidates.length === 1) return Math.round(candidates[0]);
        
        const normalized = candidates.map(bpm => {
            let b = bpm;
            while (b < 120) b *= 2;
            while (b > 150) b /= 2;
            return Math.round(b);
        });
        
        const histogram = {};
        for (const bpm of normalized) {
            let found = false;
            for (const key of Object.keys(histogram)) {
                if (Math.abs(parseFloat(key) - bpm) <= 2) {
                    histogram[key]++;
                    found = true;
                    break;
                }
            }
            if (!found) {
                histogram[bpm] = 1;
            }
        }
        
        let maxCount = 0;
        let bestBPM = normalized[0];
        for (const [bpm, count] of Object.entries(histogram)) {
            if (count > maxCount) {
                maxCount = count;
                bestBPM = parseFloat(bpm);
            }
        }
        
        return Math.round(bestBPM);
    }

    function calculateBPMConfidence(candidates, finalBPM) {
        if (candidates.length === 0) return 0;
        
        let agreementCount = 0;
        for (const bpm of candidates) {
            let normalized = bpm;
            while (normalized < 120) normalized *= 2;
            while (normalized > 150) normalized /= 2;
            
            if (Math.abs(normalized - finalBPM) <= 2) {
                agreementCount++;
            }
        }
        
        const baseConfidence = (agreementCount / candidates.length) * 100;
        return agreementCount >= 2 ? Math.min(95, baseConfidence + 10) : baseConfidence;
    }

    async function detectKeyEnhanced(buffer) {
        const sampleRate = buffer.sampleRate;
        const channelData = buffer.getChannelData(0);
        
        log('Starting key detection...');
        
        const chromagram = await calculateChromagramEnhanced(channelData, sampleRate);
        log(`Chromagram: ${chromagram.map(v => v.toFixed(3)).join(', ')}`);
        
        const ksResult = applyKrumhanslSchmuckler(chromagram);
        log(`K-S Result: ${ksResult.key}, correlation: ${ksResult.correlation.toFixed(3)}`);
        
        const harmonicResult = analyzeHarmonicEnhanced(chromagram);
        log(`Harmonic Result: ${harmonicResult.key}, score: ${harmonicResult.score.toFixed(3)}`);
        
        const finalResult = ksResult.correlation > harmonicResult.score ? ksResult : harmonicResult;
        
        return {
            key: finalResult.key,
            confidence: finalResult.correlation || finalResult.score,
            method: 'K-S + Harmonic',
            candidates: [ksResult.key, harmonicResult.key]
        };
    }

    async function calculateChromagramEnhanced(audioData, sampleRate) {
        const chromagram = new Array(12).fill(0);
        const fftSize = 8192;
        const hopSize = fftSize / 4;
        
        const numSections = Math.min(10, Math.floor(audioData.length / hopSize));
        
        for (let section = 0; section < numSections; section++) {
            const start = Math.floor(section * audioData.length / numSections);
            const end = Math.min(start + fftSize, audioData.length);
            
            if (end - start < fftSize) break;
            
            const segment = audioData.slice(start, end);
            const chroma = calculatePitchClassesFFT(segment, sampleRate);
            
            for (let i = 0; i < 12; i++) {
                chromagram[i] += chroma[i];
            }
        }
        
        const sum = chromagram.reduce((a, b) => a + b, 0);
        if (sum > 0) {
            for (let i = 0; i < 12; i++) {
                chromagram[i] /= sum;
            }
        }
        
        return chromagram;
    }

    function calculatePitchClassesFFT(signal, sampleRate) {
        const N = signal.length;
        const pitchClasses = new Array(12).fill(0);
        
        const windowed = new Float32Array(N);
        for (let i = 0; i < N; i++) {
            windowed[i] = signal[i] * (0.54 - 0.46 * Math.cos(2 * Math.PI * i / (N - 1)));
        }
        
        for (let pc = 0; pc < 12; pc++) {
            let energy = 0;
            
            for (let octave = 1; octave <= 7; octave++) {
                const freq = 440 * Math.pow(2, (pc - 9) / 12 + (octave - 4));
                
                if (freq < 30 || freq > sampleRate / 2) continue;
                
                const k = Math.round(N * freq / sampleRate);
                const omega = 2 * Math.PI * k / N;
                const cosine = Math.cos(omega);
                const sine = Math.sin(omega);
                const coeff = 2 * cosine;
                
                let s0, s1 = 0, s2 = 0;
                for (let n = 0; n < N; n++) {
                    s0 = windowed[n] + coeff * s1 - s2;
                    s2 = s1;
                    s1 = s0;
                }
                
                const real = s1 - s2 * cosine;
                const imag = s2 * sine;
                const magnitude = Math.sqrt(real * real + imag * imag);
                
                const octaveWeight = octave >= 3 && octave <= 5 ? 1.5 : 1.0;
                energy += magnitude * octaveWeight;
            }
            
            pitchClasses[pc] = energy;
        }
        
        const maxEnergy = Math.max(...pitchClasses);
        if (maxEnergy > 0) {
            for (let i = 0; i < 12; i++) {
                pitchClasses[i] /= maxEnergy;
            }
        }
        
        return pitchClasses;
    }

    function applyKrumhanslSchmuckler(chromagram) {
        let bestCorrelation = -1;
        let bestKey = '';
        let bestMode = '';
        
        for (let tonic = 0; tonic < 12; tonic++) {
            const majorCorr = pearsonCorrelation(chromagram, KEY_PROFILES.major, tonic);
            if (majorCorr > bestCorrelation) {
                bestCorrelation = majorCorr;
                bestKey = NOTE_NAMES[tonic];
                bestMode = 'major';
            }
            
            const minorCorr = pearsonCorrelation(chromagram, KEY_PROFILES.minor, tonic);
            if (minorCorr > bestCorrelation) {
                bestCorrelation = minorCorr;
                bestKey = [3, 8, 10].includes(tonic) ? NOTE_NAMES_FLAT[tonic] : NOTE_NAMES[tonic];
                bestMode = 'minor';
            }
        }
        
        return {
            key: `${bestKey} ${bestMode}`,
            correlation: Math.max(0, (bestCorrelation + 1) / 2),
            tonic: bestKey,
            mode: bestMode
        };
    }

    function pearsonCorrelation(x, y, shift) {
        const n = x.length;
        const yShifted = [...y.slice(shift), ...y.slice(0, shift)];
        
        let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0, sumY2 = 0;
        
        for (let i = 0; i < n; i++) {
            sumX += x[i];
            sumY += yShifted[i];
            sumXY += x[i] * yShifted[i];
            sumX2 += x[i] * x[i];
            sumY2 += yShifted[i] * yShifted[i];
        }
        
        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        
        return denominator === 0 ? 0 : numerator / denominator;
    }

    function analyzeHarmonicEnhanced(chromagram) {
        let maxIdx = 0;
        let maxVal = chromagram[0];
        for (let i = 1; i < 12; i++) {
            if (chromagram[i] > maxVal) {
                maxVal = chromagram[i];
                maxIdx = i;
            }
        }
        
        const tonic = NOTE_NAMES[maxIdx];
        
        const majorThird = chromagram[(maxIdx + 4) % 12];
        const minorThird = chromagram[(maxIdx + 3) % 12];
        const perfectFifth = chromagram[(maxIdx + 7) % 12];
        const majorSeventh = chromagram[(maxIdx + 11) % 12];
        const minorSeventh = chromagram[(maxIdx + 10) % 12];
        
        const majorScore = (majorThird * 1.0) + (perfectFifth * 0.8) + (majorSeventh * 0.3);
        const minorScore = (minorThird * 1.0) + (perfectFifth * 0.8) + (minorSeventh * 0.3);
        
        const mode = majorScore > minorScore ? 'major' : 'minor';
        const confidence = Math.abs(majorScore - minorScore) / Math.max(majorScore + minorScore, 0.001);
        
        return {
            key: `${tonic} ${mode}`,
            score: Math.min(1, confidence),
            tonic: tonic,
            mode: mode
        };
    }

    function getCamelotCode(key) {
        if (CAMELOT_WHEEL[key]) {
            return CAMELOT_WHEEL[key];
        }
        
        const normalized = key.replace('D#', 'Eb').replace('G#', 'Ab').replace('A#', 'Bb');
        if (CAMELOT_WHEEL[normalized]) {
            return CAMELOT_WHEEL[normalized];
        }
        
        const [note, mode] = key.split(' ');
        let noteIndex = NOTE_NAMES.indexOf(note);
        if (noteIndex === -1) noteIndex = NOTE_NAMES_FLAT.indexOf(note);
        if (noteIndex === -1) return '?';
        
        const offset = mode === 'major' ? 8 : 5;
        const camelotNumber = ((noteIndex + offset) % 12) || 12;
        const camelotLetter = mode === 'major' ? 'B' : 'A';
        
        return `${camelotNumber}${camelotLetter}`;
    }

    function displayResults(bpmResult, keyResult, duration) {
        document.getElementById('bpmValue').textContent = bpmResult.bpm;
        const candidatesText = bpmResult.candidates && bpmResult.candidates.length > 1 
            ? `Detected: ${bpmResult.candidates.map(b => Math.round(b)).join(', ')}`
            : '';
        document.getElementById('bpmCandidates').textContent = candidatesText;
        document.getElementById('bpmConfidence').style.width = bpmResult.confidence + '%';
        document.getElementById('bpmConfidenceText').textContent = `${Math.round(bpmResult.confidence)}% confidence`;
        document.getElementById('bpmMethod').textContent = bpmResult.method;
        
        document.getElementById('keyValue').textContent = keyResult.key;
        const keyCandidatesText = keyResult.candidates && keyResult.candidates.length > 1 && keyResult.candidates[0] !== keyResult.candidates[1]
            ? `Also: ${keyResult.candidates.filter(k => k !== keyResult.key).join(', ')}`
            : '';
        document.getElementById('keyCandidates').textContent = keyCandidatesText;
        const keyConfidence = (keyResult.confidence * 100) || 0;
        document.getElementById('keyConfidence').style.width = keyConfidence + '%';
        document.getElementById('keyConfidenceText').textContent = `${Math.round(keyConfidence)}% confidence`;
        document.getElementById('keyMethod').textContent = keyResult.method;
        
        const camelotCode = getCamelotCode(keyResult.key);
        document.getElementById('positionCode').textContent = camelotCode;
        document.getElementById('positionKey').textContent = keyResult.key;
        document.getElementById('camelotDetail').textContent = `${camelotCode} (${keyResult.key})`;
        document.getElementById('durationAnalyzed').textContent = `${duration.toFixed(1)}s`;
        
        const compatible = getCompatibleKeys(camelotCode);
        const compatibleKeysDiv = document.getElementById('compatibleKeys');
        compatibleKeysDiv.innerHTML = compatible.map((k, idx) => {
            const keyName = CAMELOT_TO_KEY[k] || k;
            const isPerfect = idx === 0;
            return `<div class="key-tag ${isPerfect ? 'perfect' : ''}">${k} ‚Äî ${keyName}</div>`;
        }).join('');
        
        const debugInfo = document.getElementById('debugInfo');
        debugInfo.textContent = debugLog.join('\n');
        debugInfo.classList.add('active');
        
        drawCamelotWheel(camelotCode);
        showResults();
    }

    function getCompatibleKeys(camelotCode) {
        if (camelotCode === '?') return [];
        
        const num = parseInt(camelotCode);
        const letter = camelotCode.slice(-1);
        
        const compatible = [];
        compatible.push(num + (letter === 'A' ? 'B' : 'A'));
        compatible.push((num === 12 ? 1 : num + 1) + letter);
        compatible.push((num === 1 ? 12 : num - 1) + letter);
        
        return compatible;
    }

    function drawCamelotWheel(currentCode) {
        const outerRing = document.getElementById('outerRing');
        const innerRing = document.getElementById('innerRing');
        
        outerRing.innerHTML = '';
        innerRing.innerHTML = '';
        
        const colors = [
            '#ff006e', '#ff4d6d', '#ff7aa2', '#ffa6c1', '#ffccd5',
            '#00f5ff', '#00d9ff', '#00bfff', '#0099ff', '#0066ff',
            '#6a4c93', '#9c89b8'
        ];
        
        for (let i = 0; i < 12; i++) {
            const angle = (i * 30 - 90) * Math.PI / 180;
            const xOuter = 150 + 110 * Math.cos(angle);
            const yOuter = 150 + 110 * Math.sin(angle);
            const xInner = 150 + 70 * Math.cos(angle);
            const yInner = 150 + 70 * Math.sin(angle);
            
            const codeB = (i === 0 ? 12 : i) + 'B';
            const codeA = (i === 0 ? 12 : i) + 'A';
            
            const circleB = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleB.setAttribute('cx', xOuter);
            circleB.setAttribute('cy', yOuter);
            circleB.setAttribute('r', codeB === currentCode ? 24 : 16);
            circleB.setAttribute('fill', colors[i]);
            circleB.setAttribute('opacity', codeB === currentCode ? 1 : 0.5);
            circleB.setAttribute('stroke', codeB === currentCode ? 'var(--accent-primary)' : 'none');
            circleB.setAttribute('stroke-width', codeB === currentCode ? 3 : 0);
            if (codeB === currentCode) {
                circleB.style.filter = 'drop-shadow(0 0 10px var(--accent-primary))';
            }
            outerRing.appendChild(circleB);
            
            const circleA = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circleA.setAttribute('cx', xInner);
            circleA.setAttribute('cy', yInner);
            circleA.setAttribute('r', codeA === currentCode ? 22 : 14);
            circleA.setAttribute('fill', colors[i]);
            circleA.setAttribute('opacity', codeA === currentCode ? 1 : 0.4);
            circleA.setAttribute('stroke', codeA === currentCode ? 'var(--accent-primary)' : 'none');
            circleA.setAttribute('stroke-width', codeA === currentCode ? 3 : 0);
            if (codeA === currentCode) {
                circleA.style.filter = 'drop-shadow(0 0 10px var(--accent-primary))';
            }
            innerRing.appendChild(circleA);
        }
    }

    function showAnalyzing() {
        document.getElementById('analyzing').classList.add('active');
    }

    function hideAnalyzing() {
        document.getElementById('analyzing').classList.remove('active');
    }

    function showResults() {
        document.getElementById('results').classList.add('active');
        document.getElementById('resultsCard').classList.add('active');
    }

    function hideResults() {
        document.getElementById('results').classList.remove('active');
        document.getElementById('resultsCard').classList.remove('active');
    }

    function showError(message) {
        const errorDiv = document.getElementById('error');
        errorDiv.textContent = message;
        errorDiv.classList.add('active');
    }

    function hideError() {
        document.getElementById('error').classList.remove('active');
    }

    drawCamelotWheel('8B');
</script>
```

</body>
</html>
